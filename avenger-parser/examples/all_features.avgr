// This is an example file showing all Avenger features

// Import components from other files
import { Button } from './components/button.avgr';
import { Header, Footer } from './layout';

// Enum definitions
enum CardSuit { 'clubs', 'diamonds', 'hearts', 'spades' }
export enum Status { 'pending', 'active', 'completed', 'failed' }

// Main component
component Chart {
    // Properties
    width: 100;
    height: 100;
    
    // Parameters
    param<Number> scale: 1.5;
    in param<String> title;
    out param<Boolean> interactive: true;

    // Dataset declarations
    dataset ds1: SELECT * FROM @stack(foo, field:="count", groupby:=["@foo"], sort_by:=[{field: "@c1", direction: 'desc'}]);
    
    // Conditional logic with if statement
    if (interactive) {
        Legend {
            orientation: "horizontal";
            title: "Chart Legend";
        }
    }
    
    // Match statement for different chart types
    match (charttype) {
        'bar' => {
            Bar {
                x: "category";
                y: "value";
                fill: "blue";
            }
        }
        'line' => {
            Line {
                x: "category";
                y: "value";
                stroke: "red";
            }
        }
        '_' => {
            Text {
                text: "Unsupported chart type";
                x: 50;
                y: 50;
            }
        }
    }
    
    // Component binding
    legend := Legend {
        orientation: "vertical";
        title: "Side Legend";
    }
}

enum StackOffset { 'normalize', 'zero', 'center' }
enum SortDirection { 'ascending', 'descending' }


// Functions that return a dataset are used as table functions
fn stack (
    dataset ds;
    expr field;
    expr groupby: null;
    param<StackOffset> offset: 'zero';
    param sortby: null;
    expr as_value: 'yheight';
    expr as_end: 'y2'
) -> dataset {
    match(offset) {
        'normalize' => {
            SELECT *,
                sum(@field) over (
                    order by @sortby
                    partition by @groupby
                    rows between unbounded preceding and current row
                ) / sum(1.0 * @field) over (partition by @groupby) as @as_end,
                @field / sum(1.0 * @field) over (partition by @groupby) as @as_value
                FROM @ds;
        }
        'zero' => {
            SELECT *, 
                sum(@field) over (
                    order by @sortby
                    partition by @groupby
                    rows between unbounded preceding and current row
                ) as @as_end,
                @field as @as_value
                FROM @ds;
        }
        'center' => {
            // ...
        }
    }
}

// Exported component
export component OtherComponent {
    x: 10;
    y: 20;
    stroke: 'blue';
} 