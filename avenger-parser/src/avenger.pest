// Avenger language grammar

WHITESPACE    = _{ " " | "\t" | "\r" | "\n" }
COMMENT       = _{ block_comment | line_comment }
block_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
line_comment  = _{ "//" ~ (!"\n" ~ ANY)* }

// Basic tokens
identifier           = @{ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
component_identifier = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHA | ASCII_DIGIT)* }
type_name            = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
parameter_identifier = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
function_identifier  = @{ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Export qualifier
export_qualifier = { "export" }

// Import path string
import_path = @{ string_literal_double | string_literal_single }

// Literals only used for processing strings in values
string_literal_double = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
string_literal_single = @{ "'" ~ (!"\'" ~ ANY)* ~ "'" }

// SQL query with proper handling of balanced parentheses and termination on unbalanced closing parenthesis or semicolon
sql_expr = @{
    !("}" | ")" | ";") ~ (string_literal_double | string_literal_single | balanced_parentheses | (!(";" | ")") ~ ANY))*
}

// Helper rule for balanced parentheses within expressions
balanced_parentheses = @{
    "(" ~ (string_literal_double | string_literal_single | balanced_parentheses | (!("(" | ")") ~ ANY))* ~ ")"
}

// Expression that can be used in if/match statements, surrounded by parentheses
conditional_expr = @{
    "(" ~ sql_expr ~ ")"
}

// SQL query used directly in function content
sql_statement = { sql_expr ~ ";" }

// Imports
import_item      = { component_identifier }
import_list      = { "{" ~ import_item ~ ("," ~ import_item)* ~ "}" }
import_statement = { "import" ~ import_list ~ "from" ~ import_path ~ ";" }

// Properties
property = { identifier ~ ":" ~ sql_expr ~ ";" }

// Parameter types
param_type = { "<" ~ type_name ~ ">" }

// Parameter declaration - with different formats for in vs. other qualifiers
in_parameter      = { "in" ~ "param" ~ param_type? ~ parameter_identifier ~ (":" ~ sql_expr)? ~ ";" }
out_parameter     = { "out" ~ "param" ~ param_type? ~ parameter_identifier ~ ":" ~ sql_expr ~ ";" }
private_parameter = { "param" ~ param_type? ~ parameter_identifier ~ ":" ~ sql_expr ~ ";" }
parameter         = { in_parameter | out_parameter | private_parameter }

// Expression declaration - with identical formats as parameters
in_expr      = { "in" ~ "expr" ~ param_type? ~ parameter_identifier ~ (":" ~ sql_expr)? ~ ";" }
out_expr     = { "out" ~ "expr" ~ param_type? ~ parameter_identifier ~ ":" ~ sql_expr ~ ";" }
private_expr = { "expr" ~ param_type? ~ parameter_identifier ~ ":" ~ sql_expr ~ ";" }
expr         = { in_expr | out_expr | private_expr }

// Dataset declaration - now with different formats for in vs. other qualifiers
in_dataset      = { "in" ~ "dataset" ~ parameter_identifier ~ ";" }
out_dataset     = { "out" ~ "dataset" ~ parameter_identifier ~ ":" ~ sql_expr ~ ";" }
private_dataset = { "dataset" ~ parameter_identifier ~ ":" ~ sql_expr ~ ";" }
dataset         = { in_dataset | out_dataset | private_dataset }

// Component binding
component_binding = { identifier ~ ":=" ~ component_instance }

// If statement content only allows private parameters and private datasets (no in/out qualifiers)
if_content = { (component_binding | property | private_parameter | private_expr | private_dataset | component_instance | if_statement | match_statement | sql_statement)* }

// Else branch
else_branch = { "else" ~ "{" ~ if_content ~ "}" }

// If statement with optional else branch
// Now supports both identifier directly or a conditional expression
if_statement = {
    "if" ~ (conditional_expr) ~ "{" ~ if_content ~ "}" ~ else_branch?
}

// Match case pattern - either a quoted string or underscore for default
match_pattern = { string_literal_single | "_" }

// Match case branch
match_case = { match_pattern ~ "=>" ~ "{" ~ if_content ~ "}" }

// Match statement - now requires parentheses around expression
match_statement = {
    "match" ~ conditional_expr ~ "{" ~ match_case+ ~ "}"
}

// Enum identifier must be title case (component_identifier)
enum_identifier = { component_identifier }

// Enum value is a single-quoted string
enum_value = { string_literal_single }

// Enum values list
enum_values = { enum_value ~ ("," ~ enum_value)* ~ ","? }

// Enum definition
enum_definition = {
    export_qualifier? ~ "enum" ~ enum_identifier ~ "{" ~ enum_values ~ "}"
}

// Function parameter types
kinds = { "dataset" | "param" | "expr" }

// Regular function parameter without terminator
function_param_inner = { kinds ~ param_type? ~ parameter_identifier ~ (":" ~ sql_expr)? }

// Component function parameters
component_function_params = {
    "(" ~ component_function_self ~ (";" ~ function_param_inner)* ~ ";"? ~ ")"
}

// Function parameters list
function_params = { "(" ~ function_param_inner ~ (";" ~ function_param_inner)* ~ ";"? ~ ")" }

// Callback parameters list (same as function parameters)
callback_params_inner = { "param" ~ param_type? ~ parameter_identifier ~ (":" ~ sql_expr)? | "expr" ~ param_type? ~ parameter_identifier ~ (":" ~ sql_expr)? | "dataset" ~ parameter_identifier ~ (":" ~ sql_expr)? }
callback_params       = { "(" ~ (callback_params_inner ~ (";" ~ callback_params_inner)* ~ ";")? ~ ")" }

// Empty callback parameters
empty_callback_params = { "(" ~ ")" }

// Callback declaration
callback_declaration = { "callback" ~ function_identifier ~ (callback_params | empty_callback_params | "(" ~ function_param_inner ~ (";" ~ function_param_inner)* ~ ";"? ~ ")" | "(" ~ ")") ~ ";" }

// Function content allows private parameters, expr, datasets, if and match statements, and function_sql
function_content = { (private_parameter | private_expr | private_dataset | if_statement | match_statement | sql_statement)* }

// Function definition - use 'fn' instead of 'function'
function_definition = {
    export_qualifier? ~ "fn" ~ function_identifier ~ function_params ~ "->" ~ kinds ~ "{" ~ function_content ~ "}"
}

// Self parameter (no terminator included)
component_function_self = { "self" }

// Callback event handlers
assignment_target   = { "self" | "parent" | "root" }
callback_assignment = { assignment_target ~ "." ~ identifier ~ "=" ~ sql_expr ~ ";" }

// Callback blocks can contain assignments, if statements, and match statements
callback_if_content   = { (callback_assignment | callback_if_statement | callback_match_statement | private_parameter | private_expr | private_dataset)* }
callback_if_statement = { "if" ~ conditional_expr ~ "{" ~ callback_if_content ~ "}" ~ callback_else_branch? }
callback_else_branch  = { "else" ~ "{" ~ callback_if_content ~ "}" }

// Match statements inside callbacks
callback_match_case      = { match_pattern ~ "=>" ~ "{" ~ callback_if_content ~ "}" }
callback_match_statement = { "match" ~ conditional_expr ~ "{" ~ callback_match_case+ ~ "}" }

callback_body = { "{" ~ (callback_assignment | callback_if_statement | callback_match_statement | private_parameter | private_expr | private_dataset)* ~ "}" }

// Callback parameters list for definitions
callback_def_inner  = { "param" ~ param_type? ~ parameter_identifier ~ (":" ~ sql_expr)? | "expr" ~ param_type? ~ parameter_identifier ~ (":" ~ sql_expr)? | "dataset" ~ parameter_identifier ~ (":" ~ sql_expr)? }
callback_def_params = { "(" ~ (callback_def_inner ~ (";" ~ callback_def_inner)*)? ~ ";"? ~ ")" }

// Callback definition
callback_definition = { function_identifier ~ callback_def_params ~ "=>" ~ callback_body }

// Component function can have optional out qualifier
component_function = {
    "out"? ~ "fn" ~ function_identifier ~ component_function_params ~ "->" ~ kinds ~ "{" ~ function_content ~ "}"
}

// Component instance
component_instance = {
    component_identifier ~ "{" ~ component_content ~ "}"
}

// Update component content to include component functions
component_content = _{ (component_binding | property | parameter | expr | dataset | component_instance | if_statement | match_statement | component_function | callback_declaration | callback_definition)* }

// Top-level component declaration with explicit component keyword
component_declaration = {
    export_qualifier? ~ "component" ~ component_identifier ~ "{" ~ component_content ~ "}"
}

// File is now import statements followed by enum definitions, function definitions and component declarations
file = {
    SOI ~ import_statement* ~ (enum_definition | function_definition | component_declaration)* ~ EOI
}
