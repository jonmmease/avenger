// Avenger language grammar

WHITESPACE    = _{ " " | "\t" | "\r" | "\n" }
COMMENT       = _{ block_comment | line_comment }
block_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
line_comment  = _{ "//" ~ (!"\n" ~ ANY)* }

// Basic tokens
identifier           = @{ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
component_identifier = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHA | ASCII_DIGIT)* }
type_name            = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
parameter_identifier = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }

// Export qualifier
export_qualifier = { "export" }

// Import path string
import_path = @{ string_literal_double | string_literal_single }

// Literals only used for processing strings in values
string_literal_double = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
string_literal_single = @{ "'" ~ (!"\'" ~ ANY)* ~ "'" }

// Raw value that collects everything up to semicolon, handling quoted strings properly
raw_value = @{
    (string_literal_double | string_literal_single | (!(";" | "{" | "}") ~ ANY))*
}

// SQL query is similar to raw_value but specifically for SQL content
sql_query = @{
    (string_literal_double | string_literal_single | (!(";" | "{" | "}") ~ ANY))*
}

// Expression that can be used in if/match statements, surrounded by parentheses
conditional_expr = @{
    "(" ~ (string_literal_double | string_literal_single | balanced_parentheses | (!(")" | "{" | "}") ~ ANY))* ~ ")"
}

// Helper rule for balanced parentheses within expressions
balanced_parentheses = @{
    "(" ~ (string_literal_double | string_literal_single | balanced_parentheses | (!("(" | ")") ~ ANY))* ~ ")"
}

// Imports
import_item      = { component_identifier }
import_list      = { "{" ~ import_item ~ ("," ~ import_item)* ~ "}" }
import_statement = { "import" ~ import_list ~ "from" ~ import_path ~ ";" }

// Properties
property = { identifier ~ ":" ~ raw_value ~ ";" }

// Parameter types
param_type    = { "<" ~ type_name ~ ">" }
param_default = { "=" ~ raw_value }

// Parameter declaration - with different formats for in vs. other qualifiers
in_parameter      = { "in" ~ "param" ~ param_type ~ parameter_identifier ~ ";" }
out_parameter     = { "out" ~ "param" ~ param_type ~ parameter_identifier ~ ":" ~ raw_value ~ param_default? ~ ";" }
private_parameter = { "param" ~ param_type ~ parameter_identifier ~ ":" ~ raw_value ~ param_default? ~ ";" }
parameter         = { in_parameter | out_parameter | private_parameter }

// Expression declaration - with identical formats as parameters
in_expr      = { "in" ~ "expr" ~ param_type ~ parameter_identifier ~ ";" }
out_expr     = { "out" ~ "expr" ~ param_type ~ parameter_identifier ~ ":" ~ raw_value ~ param_default? ~ ";" }
private_expr = { "expr" ~ param_type ~ parameter_identifier ~ ":" ~ raw_value ~ param_default? ~ ";" }
expr         = { in_expr | out_expr | private_expr }

// Dataset declaration - now with different formats for in vs. other qualifiers
in_dataset      = { "in" ~ "dataset" ~ parameter_identifier ~ ";" }
out_dataset     = { "out" ~ "dataset" ~ parameter_identifier ~ ":" ~ sql_query ~ ";" }
private_dataset = { "dataset" ~ parameter_identifier ~ ":" ~ sql_query ~ ";" }
dataset         = { in_dataset | out_dataset | private_dataset }

// Component binding
component_binding = { identifier ~ ":=" ~ component_instance }

// If statement content only allows private parameters and private datasets (no in/out qualifiers)
if_content = { (property | private_parameter | private_expr | private_dataset | component_binding | component_instance | if_statement | match_statement)* }

// Else branch
else_branch = { "else" ~ "{" ~ if_content ~ "}" }

// If statement with optional else branch
// Now supports either identifier or conditional expression
if_statement = {
    "if" ~ (identifier | conditional_expr) ~ "{" ~ if_content ~ "}" ~ else_branch?
}

// Match case pattern - either a quoted string or underscore for default
match_pattern = { string_literal_single | "_" }

// Match case branch
match_case = { match_pattern ~ "=>" ~ "{" ~ if_content ~ "}" }

// Match statement - now requires parentheses around expression
match_statement = {
    "match" ~ conditional_expr ~ "{" ~ match_case+ ~ "}"
}

// Enum identifier must be title case (component_identifier)
enum_identifier = { component_identifier }

// Enum value is a single-quoted string
enum_value = { string_literal_single }

// Enum values list
enum_values = { enum_value ~ ("," ~ enum_value)* ~ ","? }

// Enum definition
enum_definition = {
    export_qualifier? ~ "enum" ~ enum_identifier ~ "{" ~ enum_values ~ "}"
}

// Component instance
component_instance = {
    component_identifier ~ (":" ~ component_identifier)? ~ "{" ~ component_content ~ "}"
}

// Update component content to include the dataset rule
component_content = _{ (property | parameter | expr | dataset | component_binding | component_instance | if_statement | match_statement)* }

// Top-level component declaration
component_declaration = {
    export_qualifier? ~ "component"? ~ component_identifier ~ "{" ~ component_content ~ "}"
}

// File is now import statements followed by enum definitions and component declarations
file = {
    SOI ~ import_statement* ~ (enum_definition | component_declaration)* ~ EOI
}
